<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MIROVA - AI All-Rounder</title>
    <base href="./">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --mirova-bg-light: #f0f2f5;
            --mirova-bg-dark: #0f0c29;
            --mirova-card-light: rgba(255, 255, 255, 0.6);
            --mirova-card-dark: rgba(20, 16, 69, 0.6);
        }
        .prose :where(pre):not(:where([class~="not-prose"] *)) {
            background-color: transparent;
            padding: 0;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                    },
                    colors: {
                        'mirova-bg-light': 'var(--mirova-bg-light)',
                        'mirova-bg-dark': 'var(--mirova-bg-dark)',
                        'mirova-card-light': 'var(--mirova-card-light)',
                        'mirova-card-dark': 'var(--mirova-card-dark)',
                    },
                    boxShadow: {
                        'neon-purple': '0 0 5px rgba(168, 85, 247, 0.8), 0 0 10px rgba(168, 85, 247, 0.6)',
                        'neon-blue': '0 0 5px rgba(59, 130, 246, 0.8), 0 0 10px rgba(59, 130, 246, 0.6)',
                    },
                    animation: {
                        'splash-fade-out': 'fadeOut 0.5s ease-in-out forwards',
                        'logo-fade-in': 'fadeInScale 1s cubic-bezier(0.25, 1, 0.5, 1) forwards',
                        'text-fade-in': 'fadeIn 1s ease-in-out forwards',
                        'arrow-pulse': 'pulse 2.5s infinite ease-in-out',
                        'fade-in': 'fadeIn 0.5s ease-in-out',
                    },
                    keyframes: {
                        fadeOut: { 'from': { opacity: '1' }, 'to': { opacity: '0', visibility: 'hidden' }, },
                        fadeInScale: { 'from': { opacity: '0', transform: 'scale(0.95)' }, 'to': { opacity: '1', transform: 'scale(1)' }, },
                        fadeIn: { 'from': { opacity: '0' }, 'to': { opacity: '1' }, },
                        pulse: { '0%, 100%': { opacity: '0.6', transform: 'scale(1)' }, '50%': { opacity: '1', transform: 'scale(1.05)' }, }
                    }
                },
            },
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.27.0",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="antialiased font-sans bg-mirova-bg-light dark:bg-mirova-bg-dark text-gray-900 dark:text-gray-100 transition-colors duration-300">
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <symbol id="icon-chat" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></symbol>
        <symbol id="icon-image" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></symbol>
        <symbol id="icon-app-builder" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></symbol>
        <symbol id="icon-stt" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></symbol>
        <symbol id="icon-history" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 4v6h6"></path><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></symbol>
        <symbol id="icon-about" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></symbol>
        <symbol id="icon-user" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></symbol>
        <symbol id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></symbol>
        <symbol id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></symbol>
        <symbol id="icon-switch-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5"/><path d="M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5"/><path d="m17 12-3-3 3-3"/><path d="m7 12 3 3-3 3"/></symbol>
        <symbol id="icon-flash" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></symbol>
        <symbol id="icon-flash-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M12.87 12.87l-1.32.73-1.42 2.83 2.05 2.05.5-2.51.5-2.51h4.91l-1.29-1.29"></path><path d="M13 2l-2.29 4.58L13 11h4l-3-6-2-3z"></path><path d="M11 22l1.3-2.6"></path></symbol>
        <symbol id="icon-attach" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></symbol>
        <symbol id="icon-chat-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></symbol>
        <symbol id="icon-send" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></symbol>
        <symbol id="icon-speaker" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></symbol>
        <symbol id="icon-stop-circle" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect></symbol>
        <symbol id="icon-copy" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></symbol>
        <symbol id="icon-pencil" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></symbol>
        <symbol id="icon-download" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></symbol>
        <symbol id="icon-email" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"></path></symbol>
        <symbol id="icon-password" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></symbol>
        <symbol id="icon-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></symbol>
        <symbol id="icon-tab-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 18L18 6M6 6l12 12"></path></symbol>
        <symbol id="icon-add" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 4v16m8-8H4"></path></symbol>
        <symbol id="icon-upload" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></symbol>
    </svg>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
import React, { useState, useEffect, useContext, useRef, useCallback, useMemo, createContext } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI, GenerateContentResponse, Modality } from "@google/genai";

// ====== FROM types.ts ======
const Theme = {
  Light: 'light',
  Dark: 'dark',
};

const Feature = {
  Chat: 'Chat',
  Image: 'Image',
  MirovaCoder: 'Mirova Coder',
  STT: 'STT',
  History: 'History',
  About: 'About',
};

// ====== FROM gemini.ts ======
const API = (() => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

    const getVikasAge = () => {
        const birthday = new Date('2011-01-23');
        const today = new Date();
        let age = today.getFullYear() - birthday.getFullYear();
        const m = today.getMonth() - birthday.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthday.getDate())) {
            age--;
        }
        return age;
    };

    const getChatResponse = async (messages) => {
        const contents = messages.map(msg => {
            const parts = [];
            if (msg.images && msg.images.length > 0) {
                msg.images.forEach(imgBase64 => {
                    parts.push({
                        inlineData: {
                            mimeType: 'image/jpeg',
                            data: imgBase64,
                        }
                    });
                });
            }
            parts.push({ text: msg.text });
            return { role: msg.role, parts };
        });

        return await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: contents,
            config: {
                systemInstruction: 'You are MIROVA, a smart, creative, and conversational AI assistant. Be helpful and friendly.',
            }
        });
    };

    const getImage = async (prompt, style, aspectRatio) => {
        const fullPrompt = `${prompt}, ${style} style`;
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: fullPrompt,
            config: {
              numberOfImages: 1,
              outputMimeType: 'image/jpeg',
              aspectRatio: aspectRatio,
            },
        });
        const base64ImageBytes = response.generatedImages[0]?.image?.imageBytes;
        if (base64ImageBytes) return base64ImageBytes;
        throw new Error("No image generated in response.");
    };

    const editImage = async (prompt, images, aspectRatio) => {
        const imageParts = images.map(image => ({
            inlineData: { data: image.data, mimeType: image.mimeType }
        }));
        const fullPrompt = `${prompt}\n\nIMPORTANT: The final generated image must have a strict aspect ratio of ${aspectRatio}.`;
        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash-image',
          contents: { parts: [...imageParts, { text: fullPrompt }] },
          config: { responseModalities: [Modality.IMAGE] },
        });
        for (const part of response.candidates[0].content.parts) {
          if (part.inlineData) return part.inlineData.data;
        }
        throw new Error("No image generated in response.");
    };

    const generateCode = async (prompt, language) => {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `Based on the user's idea: "${prompt}", generate a complete, production-ready code snippet in ${language}. The code should be well-documented. Respond ONLY with the raw code for the requested language inside a single markdown code block. Do not include any explanatory text before or after the code block.`,
        });
        return response.text;
    };

    const getSpeech = async (text, voice) => {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-preview-tts",
            contents: [{ parts: [{ text: `Say this with a natural, friendly tone: ${text}` }] }],
            config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: {
                    voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } },
                },
            },
        });
        return response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
    };
    
    const transcribeAudioStream = async (audioChunks, language) => {
        const audioParts = audioChunks.map(chunk => ({
            inlineData: { mimeType: chunk.mimeType, data: chunk.data },
        }));
        const contents = {
            parts: [
                { text: `You are an expert multilingual transcription service. Transcribe the following audio recording. The primary language spoken in the audio is ${language}. Provide a precise and accurate transcription.` },
                ...audioParts,
            ],
        };
        return await ai.models.generateContentStream({
            model: 'gemini-2.5-pro',
            contents,
        });
    };

    const transcribeSpeech = async (audioChunk, language) => {
        const audioPart = {
            inlineData: { mimeType: audioChunk.mimeType, data: audioChunk.data },
        };
        const contents = {
            parts: [
                { text: `You are an expert multilingual transcription service. Transcribe the following audio recording. The primary language spoken in the audio is ${language}. Provide a precise and accurate transcription. Respond only with the transcribed text.` },
                audioPart,
            ],
        };
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents,
        });
        return response.text;
    };

    function decode(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }

    async function decodeAudioData(data, ctx, sampleRate, numChannels) {
        const dataInt16 = new Int16Array(data.buffer);
        const frameCount = dataInt16.length / numChannels;
        const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);
        for (let channel = 0; channel < numChannels; channel++) {
            const channelData = buffer.getChannelData(channel);
            for (let i = 0; i < frameCount; i++) {
                channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
            }
        }
        return buffer;
    }

    let audioContext = null;
    let currentSource = null;

    const playAudio = async (base64Audio, onEnded = () => {}) => {
        if (currentSource) {
            currentSource.onended = null;
            currentSource.stop();
            currentSource.disconnect();
        }
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        }
        const audioBuffer = await decodeAudioData(decode(base64Audio), audioContext, 24000, 1);
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start();
        source.onended = () => {
            if (currentSource === source) currentSource = null;
            onEnded();
        };
        currentSource = source;
    };

    const stopAudio = () => {
        if (currentSource) currentSource.stop();
    };
    
    return { getVikasAge, getChatResponse, getImage, editImage, generateCode, getSpeech, transcribeAudioStream, transcribeSpeech, playAudio, stopAudio };
})();


// ====== FROM store.tsx ======
const AuthContext = createContext(null);
const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(() => {
    try {
      const storedUser = localStorage.getItem('mirova-user');
      return storedUser ? JSON.parse(storedUser) : null;
    } catch { return null; }
  });

  useEffect(() => {
    if (user) localStorage.setItem('mirova-user', JSON.stringify(user));
    else localStorage.removeItem('mirova-user');
  }, [user]);

  const login = useCallback((userData) => setUser(userData), []);
  const logout = useCallback(() => setUser(null), []);
  
  const value = useMemo(() => ({ user, login, logout }), [user, login, logout]);
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

const useTabManager = (initialTabFactory) => {
    const [state, setState] = useState(() => {
        const firstTab = initialTabFactory(`${Date.now()}`, 1);
        return { tabs: [firstTab], activeTabId: firstTab.id };
    });
    const setActiveTabId = useCallback((tabId) => setState(prev => ({ ...prev, activeTabId: tabId })), []);
    const addTab = useCallback((tabData) => {
        setState(prev => {
            const newTab = tabData ? { ...tabData, id: `${Date.now()}` } : initialTabFactory(`${Date.now()}`, prev.tabs.length + 1);
            return { tabs: [...prev.tabs, newTab], activeTabId: newTab.id };
        });
    }, [initialTabFactory]);
    const closeTab = useCallback((tabId) => {
        setState(prev => {
            const newTabs = prev.tabs.filter(t => t.id !== tabId);
            if (newTabs.length === 0) {
                const newTab = initialTabFactory(`${Date.now()}`, 1);
                return { tabs: [newTab], activeTabId: newTab.id };
            }
            let newActiveId = prev.activeTabId;
            if (prev.activeTabId === tabId) newActiveId = newTabs[newTabs.length - 1].id;
            return { tabs: newTabs, activeTabId: newActiveId };
        });
    }, [initialTabFactory]);
    const updateTab = useCallback((tabId, updates) => {
        setState(prev => ({ ...prev, tabs: prev.tabs.map(tab => tab.id === tabId ? { ...tab, ...updates } : tab) }));
    }, []);
    return { ...state, setActiveTabId, addTab, closeTab, updateTab };
};

const chatTabFactory = (id, count) => ({ id, name: `Chat ${count}`, messages: [] });
const ChatContext = createContext(null);
const ChatProvider = ({ children }) => {
    const value = useTabManager(chatTabFactory);
    return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
};
const imageTabFactory = (id, count) => ({ id, name: `Image ${count}`, prompt: '', style: 'Realistic', resolution: '1:1', sourceImages: [], generatedImage: null });
const ImageContext = createContext(null);
const ImageProvider = ({ children }) => {
    const value = useTabManager(imageTabFactory);
    return <ImageContext.Provider value={value}>{children}</ImageContext.Provider>;
};
const coderTabFactory = (id, count) => ({ id, name: `Code ${count}`, prompt: '', result: '', language: 'JavaScript' });
const CoderContext = createContext(null);
const CoderProvider = ({ children }) => {
    const value = useTabManager(coderTabFactory);
    return <CoderContext.Provider value={value}>{children}</CoderContext.Provider>;
};
const SttContext = createContext(null);
const SttProvider = ({ children }) => {
    const [transcription, setTranscription] = useState('');
    const [language, setLanguage] = useState('Telugu');
    const value = useMemo(() => ({ transcription, setTranscription, language, setLanguage }), [transcription, language]);
    return <SttContext.Provider value={value}>{children}</SttContext.Provider>;
};

const HistoryContext = createContext(null);
const HistoryProvider = ({ children }) => {
    const { user } = useContext(AuthContext);
    const [history, setHistory] = useState([]);
    useEffect(() => {
        if (user?.email) {
            try {
                const storedHistory = localStorage.getItem(`mirova-history-${user.email}`);
                setHistory(storedHistory ? JSON.parse(storedHistory) : []);
            } catch { setHistory([]); }
        } else { setHistory([]); }
    }, [user]);
    useEffect(() => {
        if (user?.email) localStorage.setItem(`mirova-history-${user.email}`, JSON.stringify(history));
    }, [history, user]);
    const addHistoryItem = useCallback((item) => {
        const newItem = { ...item, id: Date.now().toString(), timestamp: new Date().toISOString() };
        setHistory(prev => [newItem, ...prev.filter(h => {
            if ('id' in h.payload && 'id' in newItem.payload) return h.payload.id !== newItem.payload.id;
            return true;
        })]);
    }, []);
    const clearHistory = useCallback(() => setHistory([]), []);
    const value = useMemo(() => ({ history, addHistoryItem, clearHistory }), [history, addHistoryItem, clearHistory]);
    return <HistoryContext.Provider value={value}>{children}</HistoryContext.Provider>;
};

// ====== FROM components.tsx ======
const ChatIcon = ({ className }) => (<svg className={className}><use href="#icon-chat" /></svg>);
const ImageIcon = ({ className }) => (<svg className={className}><use href="#icon-image" /></svg>);
const AppBuilderIcon = ({ className }) => (<svg className={className}><use href="#icon-app-builder" /></svg>);
const SttIcon = ({ className }) => (<svg className={className}><use href="#icon-stt" /></svg>);
const HistoryIcon = ({ className }) => (<svg className={className}><use href="#icon-history" /></svg>);
const AboutIcon = ({ className }) => (<svg className={className}><use href="#icon-about" /></svg>);
const UserIcon = ({ className }) => (<svg className={className}><use href="#icon-user" /></svg>);
const SunIcon = ({ className }) => (<svg className={className}><use href="#icon-sun" /></svg>);
const MoonIcon = ({ className }) => (<svg className={className}><use href="#icon-moon" /></svg>);
const SwitchCameraIcon = ({ className }) => (<svg className={className}><use href="#icon-switch-camera" /></svg>);
const FlashIcon = ({ className }) => (<svg className={className}><use href="#icon-flash" /></svg>);
const FlashOffIcon = ({ className }) => (<svg className={className}><use href="#icon-flash-off" /></svg>);
const AttachIcon = ({ className }) => (<svg className={className}><use href="#icon-attach" /></svg>);
const ChatCameraIcon = ({ className }) => (<svg className={className}><use href="#icon-chat-camera" /></svg>);
const SendIcon = ({ className }) => (<svg className={className}><use href="#icon-send" /></svg>);
const SpeakerIcon = ({ className }) => (<svg className={className}><use href="#icon-speaker" /></svg>);
const StopCircleIcon = ({ className }) => (<svg className={className}><use href="#icon-stop-circle" /></svg>);
const CopyIcon = ({ className }) => (<svg className={className}><use href="#icon-copy" /></svg>);
const PencilIcon = ({ className }) => (<svg className={className}><use href="#icon-pencil" /></svg>);
const DownloadIcon = ({ className }) => (<svg className={className}><use href="#icon-download" /></svg>);
const EmailIcon = ({ className }) => (<svg className={className}><use href="#icon-email" /></svg>);
const PasswordIcon = ({ className }) => (<svg className={className}><use href="#icon-password" /></svg>);
const CloseIcon = ({ className }) => (<svg className={className}><use href="#icon-close" /></svg>);
const TabCloseIcon = ({ className }) => (<svg className={className}><use href="#icon-tab-close" /></svg>);
const AddIcon = ({ className }) => (<svg className={className}><use href="#icon-add" /></svg>);
const UploadIcon = ({ className }) => (<svg className={className}><use href="#icon-upload" /></svg>);

const GlassCard = ({ children, className }) => (<div className={`bg-mirova-card-light/60 dark:bg-mirova-card-dark/60 backdrop-blur-xl rounded-2xl p-6 shadow-lg ring-1 ring-white/10 ${className}`}>{children}</div>);
const LoadingSpinner = ({ size = 'md' }) => {
    const sizeClasses = size === 'sm' ? 'h-5 w-5 border-2' : 'h-16 w-16 border-t-4 border-b-4';
    const marginClass = size === 'md' ? 'my-8' : '';
    return (<div className={`flex justify-center items-center ${marginClass}`}><div className={`animate-spin rounded-full border-purple-500 ${sizeClasses}`}></div></div>);
};
const Header = ({ theme, setTheme }) => {
    const { user, logout } = useContext(AuthContext);
    return (
        <header className="fixed top-0 left-0 right-0 z-20 bg-transparent backdrop-blur-md">
            <div className="container mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex items-center justify-between h-16">
                    <div className="flex-shrink-0"><h1 className="text-2xl font-bold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-blue-400">MIROVA</h1></div>
                    <div className="flex items-center gap-4">
                        <button onClick={() => setTheme(theme === Theme.Light ? Theme.Dark : Theme.Light)} className="p-2 rounded-full hover:bg-white/10 transition-colors">{theme === Theme.Light ? <MoonIcon className="w-5 h-5"/> : <SunIcon className="w-5 h-5"/>}</button>
                        {user && (<div className="flex items-center gap-3">
                            <div className="flex items-center gap-2">
                                <div className="w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center text-white font-bold text-sm ring-2 ring-white/20">{user.firstName?.charAt(0).toUpperCase()}</div>
                                <span className="text-sm font-semibold hidden sm:inline">{`${user.firstName} ${user.lastName}`}</span>
                            </div>
                            <button onClick={logout} className="px-3 py-1 bg-red-500 text-white text-sm font-semibold rounded-md hover:bg-red-600 transition-colors">Logout</button>
                        </div>)}
                    </div>
                </div>
            </div>
        </header>
    );
};
const FloatingMenu = ({ activeFeature, setActiveFeature }) => {
    const features = [ { name: Feature.Chat, icon: ChatIcon }, { name: Feature.Image, icon: ImageIcon }, { name: Feature.MirovaCoder, icon: AppBuilderIcon }, { name: Feature.STT, icon: SttIcon }, { name: Feature.History, icon: HistoryIcon }, { name: Feature.About, icon: AboutIcon } ];
    return (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-20">
            <div className="flex items-center justify-center gap-2 bg-mirova-card-light/80 dark:bg-mirova-card-dark/80 backdrop-blur-lg rounded-full shadow-2xl p-2 ring-1 ring-white/10">
                {features.map(({ name, icon: Icon }) => (<button key={name} onClick={() => setActiveFeature(name)} className={`w-14 h-14 sm:w-16 sm:h-16 rounded-full flex flex-col items-center justify-center transition-all duration-300 ${activeFeature === name ? 'bg-purple-600 text-white shadow-neon-purple' : 'text-gray-600 dark:text-gray-300 hover:bg-white/20'}`} aria-label={name}><Icon className="w-6 h-6 sm:w-7 sm:h-7" /><span className="text-[10px] mt-1">{name}</span></button>))}
            </div>
        </div>
    );
};
const AuthInput = ({ icon, type, placeholder, value, onChange, isInvalid }) => (<div className={`flex items-center bg-black/30 rounded-lg p-3 ring-1 ${isInvalid ? 'ring-red-500' : 'ring-white/20 focus-within:ring-cyan-400'}`}><span className="text-white/60 mr-3">{icon}</span><input type={type} placeholder={placeholder} value={value} onChange={onChange} className="w-full bg-transparent text-white focus:outline-none"/></div>);
const TabView = ({ tabs, activeTabId, onTabClick, onAddTab, onCloseTab, featureName }) => {
    const scrollContainerRef = useRef(null);
    useEffect(() => {
        const activeTab = scrollContainerRef.current?.querySelector(`[data-tab-id="${activeTabId}"]`);
        activeTab?.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    }, [activeTabId]);
    return (
        <div className="flex items-center border-b border-white/10 mb-4">
            <div ref={scrollContainerRef} className="flex-grow flex items-center gap-2 overflow-x-auto" style={{ scrollbarWidth: 'none' }}>
                {tabs.map((tab, index) => (
                    <div key={tab.id} data-tab-id={tab.id} onClick={() => onTabClick(tab.id)} className={`flex items-center gap-2 cursor-pointer px-4 py-2 border-b-2 transition-colors duration-200 whitespace-nowrap ${activeTabId === tab.id ? 'border-purple-500 text-purple-400' : 'border-transparent text-gray-400 hover:text-white'}`}>
                        <span className="text-sm font-medium">{tab.name || `${featureName} ${index + 1}`}</span>
                        {tabs.length > 1 && (<button onClick={(e) => { e.stopPropagation(); onCloseTab(tab.id); }} className="w-5 h-5 rounded-full hover:bg-white/20 flex items-center justify-center" aria-label="Close tab"><TabCloseIcon className="w-3 h-3" /></button>)}
                    </div>
                ))}
            </div>
            <button onClick={onAddTab} className="flex-shrink-0 ml-2 p-2 rounded-full hover:bg-white/10 text-gray-400 hover:text-white" aria-label="New tab"><AddIcon className="w-5 h-5" /></button>
        </div>
    );
};
const AnimatedMirovaLogo = () => (
    <div className="relative w-64 h-72 flex flex-col items-center justify-center">
        <svg viewBox="0 0 200 200" className="w-56 h-56">
            <defs>
                <linearGradient id="logo-gradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stopColor="#8A2BE2" /><stop offset="100%" stopColor="#00F0FF" /></linearGradient>
                <filter id="logo-glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="3" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
            </defs>
            <g className="opacity-0 animate-logo-fade-in" filter="url(#logo-glow)">
                <ellipse cx="100" cy="100" rx="40" ry="90" stroke="url(#logo-gradient)" strokeWidth="2" fill="none" transform="rotate(45 100 100)" className="animate-[spin_10s_linear_infinite]" style={{ animationDelay: '0.2s' }} />
                <ellipse cx="100" cy="100" rx="60" ry="90" stroke="url(#logo-gradient)" strokeWidth="2" fill="none" transform="rotate(-30 100 100)" className="animate-[spin_12s_linear_infinite_reverse]" />
                <ellipse cx="100" cy="100" rx="90" ry="50" stroke="url(#logo-gradient)" strokeWidth="2" fill="none" className="animate-[spin_15s_linear_infinite]" style={{ animationDelay: '0.5s' }} />
                <path d="M 50 150 L 75 75 L 100 125 L 125 75 L 150 150" stroke="white" strokeWidth="5" strokeLinecap="round" fill="none" className="opacity-0 animate-logo-fade-in" style={{ animationDelay: '0.8s' }} />
            </g>
        </svg>
        <div className="opacity-0 animate-text-fade-in" style={{ animationDelay: '1.5s' }}>
             <h1 className="text-5xl font-bold tracking-widest text-white mt-4" style={{ filter: 'drop-shadow(0 0 10px rgba(138, 43, 226, 0.8))' }}>MIROVA</h1>
        </div>
    </div>
);
const SplashScreen = () => (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-mirova-bg-dark animate-splash-fade-out" style={{ animationDelay: '3.0s' }}>
        <div className="absolute inset-0 z-0 overflow-hidden">
            <div className="absolute top-0 -left-1/4 w-full h-full bg-gradient-to-br from-purple-900/50 via-blue-900/30 to-transparent rounded-full filter blur-3xl animate-pulse opacity-50"></div>
            <div className="absolute bottom-0 -right-1/4 w-full h-full bg-gradient-to-tl from-indigo-900/50 via-pink-900/30 to-transparent rounded-full filter blur-3xl animate-pulse animation-delay-4000 opacity-50"></div>
        </div>
        <AnimatedMirovaLogo />
    </div>
);

// ====== FROM auth.tsx ======
const AuthScreens = () => {
    const [screen, setScreen] = useState('welcome');
    const renderScreen = () => {
        switch (screen) {
            case 'login': return <LoginScreen />;
            case 'welcome': default: return <WelcomeScreen setScreen={setScreen} />;
        }
    };
    return <div className="min-h-screen w-full flex items-center justify-center bg-gradient-to-br from-[#3C1053] to-[#ad5389] p-4">{renderScreen()}</div>;
};
const WelcomeScreen = ({setScreen}) => (
    <div className="text-center text-white animate-fade-in">
        <h1 className="text-6xl font-bold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-blue-400 mb-2">MIROVA</h1>
        <p className="text-lg text-white/80 mb-8">Your All-in-One AI Companion.</p>
        <div className="space-y-4"><button onClick={() => setScreen('login')} className="w-64 py-3 bg-cyan-400 text-slate-900 font-bold rounded-lg shadow-lg hover:scale-105 transition-transform">Login to Continue</button></div>
    </div>
);
const LoginScreen = () => {
    const { login } = useContext(AuthContext);
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const handleLogin = () => {
        setError('');
        if (!firstName.trim() || !lastName.trim() || !email.trim() || !password.trim()) { setError('Please fill in all fields.'); return; }
        if (password.length > 8) { setError('Password must be 8 characters or less.'); return; }
        login({ firstName, lastName, email });
    };
    return (
        <div className="w-full max-w-md p-8 space-y-6 bg-black/20 backdrop-blur-lg rounded-2xl ring-1 ring-white/10 text-white animate-fade-in">
            <div className="text-center">
                <h2 className="text-3xl font-bold">Welcome to MIROVA 👋</h2>
                <p className="text-white/70 mt-2">Create your account to begin.</p>
            </div>
            {error && <p className="text-red-400 text-center bg-red-900/50 p-2 rounded-md">{error}</p>}
            <div className="space-y-4">
                <AuthInput icon={<UserIcon className="w-5 h-5" />} type="text" placeholder="First Name" value={firstName} onChange={e => setFirstName(e.target.value)} isInvalid={!!error}/>
                <AuthInput icon={<UserIcon className="w-5 h-5" />} type="text" placeholder="Last Name" value={lastName} onChange={e => setLastName(e.target.value)} isInvalid={!!error}/>
                <AuthInput icon={<EmailIcon className="w-5 h-5" />} type="email" placeholder="Enter any email address" value={email} onChange={e => setEmail(e.target.value)} isInvalid={!!error}/>
                <AuthInput icon={<PasswordIcon className="w-5 h-5" />} type="password" placeholder="Password (up to 8 characters)" value={password} onChange={e => setPassword(e.target.value)} isInvalid={!!error}/>
            </div>
            <button onClick={handleLogin} className="w-full py-3 bg-cyan-400 text-slate-900 font-bold rounded-lg shadow-lg hover:scale-105 transition-transform mt-4">Login</button>
        </div>
    );
};

// ====== FROM features.tsx ======
const fileToBase64 = (file) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
        const result = reader.result;
        const mimeType = result.split(':')[1].split(';')[0];
        const base64Data = result.split(',')[1];
        resolve({ data: base64Data, mimeType });
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
});
const useSpeechToText = (onTranscription, language) => {
    const [status, setStatus] = useState('idle');
    const mediaRecorderRef = useRef(null);
    const audioChunksRef = useRef([]);
    const startRecording = async () => {
        if (status !== 'idle') return;
        setStatus('recording');
        audioChunksRef.current = [];
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            mediaRecorderRef.current.ondataavailable = (event) => audioChunksRef.current.push(event.data);
            mediaRecorderRef.current.start();
        } catch (err) {
            console.error("Microphone access error:", err);
            alert("Could not access microphone. Please grant permission.");
            setStatus('idle');
        }
    };
    const stopRecording = () => {
        if (status !== 'recording' || !mediaRecorderRef.current) return;
        mediaRecorderRef.current.onstop = async () => {
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = async () => {
                const base64data = reader.result;
                const audio = { data: base64data.split(',')[1], mimeType: 'audio/webm' };
                try {
                    const transcription = await API.transcribeSpeech(audio, language);
                    onTranscription(transcription);
                } catch (e) {
                    console.error("Transcription failed:", e);
                    alert("Sorry, I couldn't understand that. Please try again.");
                } finally { setStatus('idle'); }
            };
            mediaRecorderRef.current?.stream.getTracks().forEach(track => track.stop());
        };
        mediaRecorderRef.current.stop();
        setStatus('transcribing');
    };
    const toggleRecording = () => {
        if (status === 'recording') stopRecording();
        else if (status === 'idle') startRecording();
    };
    return { status, toggleRecording };
};
const CameraView = ({ onCapture, onClose }) => {
    const videoRef = useRef(null), canvasRef = useRef(null), streamRef = useRef(null);
    const [facingMode, setFacingMode] = useState('user');
    const [isTorchOn, setIsTorchOn] = useState(false);
    const [isTorchSupported, setIsTorchSupported] = useState(false);
    useEffect(() => {
        let active = true;
        const openCamera = async () => {
            if (streamRef.current) streamRef.current.getTracks().forEach(track => track.stop());
            setIsTorchOn(false);
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode } });
                if (!active) { stream.getTracks().forEach(track => track.stop()); return; }
                streamRef.current = stream;
                if (videoRef.current) videoRef.current.srcObject = stream;
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack && 'getCapabilities' in videoTrack) {
                    try {
                        const capabilities = videoTrack.getCapabilities();
                        if (capabilities.torch) setIsTorchSupported(true);
                        else setIsTorchSupported(false);
                    } catch (e) {
                        console.warn("Could not read camera capabilities:", e);
                        setIsTorchSupported(false);
                    }
                } else setIsTorchSupported(false);
            } catch (err) {
                console.error("Error accessing camera:", err);
                if (!active) return;
                if (facingMode === 'environment') {
                    console.warn("Back camera not found or not available, falling back to front camera.");
                    setFacingMode('user');
                } else {
                    alert("Could not access camera. Please grant permission.");
                    onClose();
                }
            }
        };
        openCamera();
        return () => {
            active = false;
            if (streamRef.current) streamRef.current.getTracks().forEach(track => track.stop());
        };
    }, [onClose, facingMode]);
    const handleCapture = () => {
        if (videoRef.current && canvasRef.current) {
            const video = videoRef.current, canvas = canvasRef.current;
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            if (context) {
                if (facingMode === 'user') { context.translate(video.videoWidth, 0); context.scale(-1, 1); }
                context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                const base64Data = canvas.toDataURL('image/jpeg').split(',')[1];
                onCapture(base64Data);
                onClose();
            }
        }
    };
    const switchCamera = () => setFacingMode(prev => (prev === 'user' ? 'environment' : 'user'));
    const toggleTorch = async () => {
        if (!streamRef.current || !isTorchSupported || facingMode !== 'environment') return;
        const videoTrack = streamRef.current.getVideoTracks()[0];
        try {
            await videoTrack.applyConstraints({ advanced: [{ torch: !isTorchOn }] });
            setIsTorchOn(!isTorchOn);
        } catch (err) {
            console.error('Failed to toggle torch:', err);
            alert('Could not control the flashlight.');
        }
    };
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex flex-col items-center justify-center">
            <video ref={videoRef} autoPlay playsInline className={`w-full max-w-lg rounded-lg ${facingMode === 'user' ? 'transform scale-x-[-1]' : ''}`}></video>
            <canvas ref={canvasRef} className="hidden"></canvas>
            <div className="absolute bottom-10 flex w-full max-w-lg items-center px-4">
                 <div className="flex-1 flex justify-start gap-4">
                     <button onClick={onClose} className="p-3 bg-white/20 text-white rounded-full backdrop-blur-sm"><CloseIcon className="w-6 h-6"/></button>
                    {isTorchSupported && facingMode === 'environment' && (<button onClick={toggleTorch} className="p-3 bg-white/20 text-white rounded-full backdrop-blur-sm" aria-label="Toggle flash">{isTorchOn ? <FlashIcon className="w-6 h-6" /> : <FlashOffIcon className="w-6 h-6" />}</button>)}
                </div>
                <div className="flex-shrink-0"><button onClick={handleCapture} className="w-20 h-20 rounded-full bg-white flex items-center justify-center ring-4 ring-white/30" aria-label="Capture photo"><div className="w-16 h-16 rounded-full bg-white ring-2 ring-black"></div></button></div>
                <div className="flex-1 flex justify-end"><button onClick={switchCamera} className="p-3 bg-white/20 text-white rounded-full backdrop-blur-sm" aria-label="Switch camera"><SwitchCameraIcon className="w-6 h-6" /></button></div>
            </div>
        </div>
    );
};
const MessageBubble = ({ msg, editingMessage, playingMessageId, setEditingMessage, handleEditSave, handleCopy, handlePlaybackToggle }) => {
    const isEditing = editingMessage?.id === msg.id;
    return (
        <div className={`group flex items-end gap-2 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
            {msg.role === 'user' && !isEditing && (
                <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button onClick={() => setEditingMessage({ id: msg.id, text: msg.text })} className="p-1.5 rounded-full hover:bg-white/20"><PencilIcon className="w-4 h-4 text-white"/></button>
                    <button onClick={() => handleCopy(msg.text)} className="p-1.5 rounded-full hover:bg-white/20"><CopyIcon className="w-4 h-4 text-white"/></button>
                </div>
            )}
            <div className={`relative max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-2xl ${msg.role === 'user' ? 'bg-purple-600 text-white rounded-br-none' : 'bg-mirova-card-light dark:bg-mirova-card-dark text-gray-800 dark:text-gray-200 rounded-bl-none'}`}>
                {msg.role === 'model' && msg.audio && (<button onClick={() => handlePlaybackToggle(msg)} className="absolute -top-2 -right-2 w-7 h-7 bg-white dark:bg-gray-700 rounded-full flex items-center justify-center shadow-md text-purple-600 dark:text-purple-400 z-10" aria-label={playingMessageId === msg.id ? "Stop speech" : "Play speech"}>{playingMessageId === msg.id ? <StopCircleIcon className="w-4 h-4" /> : <SpeakerIcon className="w-4 h-4" />}</button>)}
                {msg.images && msg.images.length > 0 && (
                    <div className={`grid gap-2 mb-2 ${msg.images.length > 1 ? 'grid-cols-2' : 'grid-cols-1'}`}>
                        {msg.images.map((img, index) => <img key={index} src={`data:image/jpeg;base64,${img}`} alt={`user upload ${index + 1}`} className="rounded-lg max-h-48 w-full object-cover" />)}
                    </div>
                )}
                {isEditing ? (
                    <div className="space-y-2">
                        <textarea value={editingMessage.text} onChange={e => setEditingMessage({...editingMessage, text: e.target.value})} className="w-full bg-black/20 text-white p-2 rounded-md focus:outline-none" autoFocus/>
                        <div className="flex justify-end gap-2">
                            <button onClick={() => setEditingMessage(null)} className="px-3 py-1 text-xs bg-gray-500 rounded">Cancel</button>
                            <button onClick={handleEditSave} className="px-3 py-1 text-xs bg-green-500 rounded">Save & Send</button>
                        </div>
                    </div>
                ) : <div className="prose prose-sm dark:prose-invert max-w-none" dangerouslySetInnerHTML={{ __html: window.marked.parse(msg.text || '') }} />}
            </div>
            {msg.role === 'model' && (
                 <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity"><button onClick={() => handleCopy(msg.text)} className="p-1.5 rounded-full hover:bg-black/10 dark:hover:bg-white/20"><CopyIcon className="w-4 h-4 text-gray-500 dark:text-gray-400"/></button></div>
            )}
        </div>
    );
};
const ChatInputBar = ({ input, setInput, images, setImages, isLoading, handleSend, sttStatus, toggleRecording, handleFileUpload, setIsCameraOpen }) => {
    const fileInputRef = useRef(null), textareaRef = useRef(null);
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
        }
    }, [input]);
    const canSend = (input.trim().length > 0 || images.length > 0) && !isLoading;
    return (
        <div className="fixed bottom-24 left-1/2 -translate-x-1/2 w-[95%] max-w-lg z-10">
             {images.length > 0 && (<div className="mb-2 p-2 bg-black/10 dark:bg-white/5 rounded-lg"><div className="flex space-x-2 overflow-x-auto">{images.map((img, index) => (<div key={index} className="relative flex-shrink-0 w-20 h-20"><img src={`data:image/jpeg;base64,${img}`} className="w-full h-full object-cover rounded-md"/><button onClick={() => setImages(images.filter((_, i) => i !== index))} className="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold">X</button></div>))}</div></div>)}
            <div className="flex items-end gap-2 bg-mirova-card-light dark:bg-mirova-card-dark backdrop-blur-lg rounded-2xl shadow-lg p-2 ring-1 ring-white/10">
                <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="image/*" className="hidden" multiple />
                <button onClick={() => fileInputRef.current?.click()} className="p-2 text-gray-600 dark:text-gray-300 hover:text-purple-500 transition-colors flex-shrink-0" aria-label="Attach file"><AttachIcon className="w-6 h-6" /></button>
                <button onClick={() => setIsCameraOpen(true)} className="p-2 text-gray-600 dark:text-gray-300 hover:text-purple-500 transition-colors flex-shrink-0" aria-label="Open camera"><ChatCameraIcon className="w-6 h-6" /></button>
                <textarea ref={textareaRef} rows={1} value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (canSend) handleSend(); }}} placeholder="Message MIROVA..." className="flex-grow bg-transparent focus:outline-none px-2 resize-none max-h-40 overflow-y-auto text-gray-800 dark:text-gray-200"/>
                 <button onClick={toggleRecording} className="p-2 text-gray-600 dark:text-gray-300 hover:text-purple-500 transition-colors flex-shrink-0" aria-label="Use microphone">{sttStatus === 'transcribing' ? <LoadingSpinner size="sm" /> : sttStatus === 'recording' ? <div className="w-6 h-6 flex items-center justify-center text-red-500"><SttIcon className="w-6 h-6 animate-pulse" /></div> : <SttIcon className="w-6 h-6" />}</button>
                <button onClick={handleSend} className="flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-purple-600 text-white shadow-md transition-colors hover:bg-purple-700 disabled:cursor-not-allowed disabled:opacity-50" disabled={!canSend} aria-label="Send message"><SendIcon className="h-5 w-5" /></button>
            </div>
        </div>
    );
};
const ChatView = () => {
    const { addHistoryItem } = useContext(HistoryContext);
    const { tabs, activeTabId, setActiveTabId, addTab, closeTab, updateTab } = useContext(ChatContext);
    const { language } = useContext(SttContext);
    const [input, setInput] = useState('');
    const [images, setImages] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [isCameraOpen, setIsCameraOpen] = useState(false);
    const [playingMessageId, setPlayingMessageId] = useState(null);
    const [editingMessage, setEditingMessage] = useState(null);
    const messagesEndRef = useRef(null);
    const activeTab = tabs.find(t => t.id === activeTabId);
    const messages = activeTab?.messages || [];
    const handleTranscription = (text) => {
        if (editingMessage) setEditingMessage(prev => prev ? { ...prev, text: prev.text ? `${prev.text} ${text}` : text } : null);
        else setInput(prev => prev ? `${prev} ${text}` : text);
    };
    const { status: sttStatus, toggleRecording } = useSpeechToText(handleTranscription, language);
    const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    useEffect(scrollToBottom, [messages]);
    const handleFileUpload = async (event) => {
        const files = event.target.files;
        if (files) {
           if (images.length + files.length > 50) { alert('You can upload a maximum of 50 images.'); return; }
           const filePromises = [...files].map(fileToBase64);
           const results = await Promise.all(filePromises);
           const base64Images = results.map(r => r.data);
           setImages(prev => [...prev, ...base64Images]);
        }
    };
    const handlePhotoCapture = (imageBase64) => {
        if (images.length < 50) setImages(prev => [...prev, imageBase64]);
        else alert('You can upload a maximum of 50 images.');
    };
    const handlePlaybackToggle = async (message) => {
        if (!message.audio) return;
        if (playingMessageId === message.id) {
            API.stopAudio();
            setPlayingMessageId(null);
        } else {
            if (playingMessageId) API.stopAudio();
            await API.playAudio(message.audio, () => setPlayingMessageId(null));
            setPlayingMessageId(message.id);
        }
    };
    const performSend = async (messageHistory, newTabName) => {
        if (!activeTab) return;
        setIsLoading(true);
        updateTab(activeTab.id, { messages: messageHistory, name: newTabName || activeTab.name });
        const lowerCaseInput = messageHistory[messageHistory.length - 1].text.toLowerCase();
        if (lowerCaseInput.includes('who is your developer') || lowerCaseInput.includes('who created you') || lowerCaseInput.includes('who is your owner')) {
            const age = API.getVikasAge();
            const replyText = `I was developed by G. Vikas, a ${age}-year-old child.`;
            let audio;
            try { audio = await API.getSpeech(replyText, 'Kore'); } catch (e) { console.error("Speech generation failed:", e); }
            const reply = { id: (Date.now() + 1).toString(), role: 'model', text: replyText, audio: audio };
            const finalConversation = [...messageHistory, reply];
            updateTab(activeTab.id, { messages: finalConversation });
            setIsLoading(false);
            addHistoryItem({ feature: Feature.Chat, payload: { ...activeTab, messages: finalConversation, name: newTabName || activeTab.name } });
            if (audio) await handlePlaybackToggle({ ...reply, id: reply.id });
            return;
        }
        try {
            const response = await API.getChatResponse(messageHistory);
            let audio;
            if (response.text) {
                try { audio = await API.getSpeech(response.text, 'Kore'); } 
                catch (speechError) { console.error("Speech generation failed:", speechError); }
            }
            const modelMessage = { id: (Date.now() + 1).toString(), role: 'model', text: response.text, audio: audio };
            const finalConversation = [...messageHistory, modelMessage];
            updateTab(activeTab.id, { messages: finalConversation });
            addHistoryItem({ feature: Feature.Chat, payload: { ...activeTab, messages: finalConversation, name: newTabName || activeTab.name } });
            if (audio) await handlePlaybackToggle({ ...modelMessage, id: modelMessage.id });
        } catch (error) {
            console.error("Error fetching chat response:", error);
            const errorMessage = { id: (Date.now() + 1).toString(), role: 'model', text: "Sorry, I encountered an error. Please try again." };
            updateTab(activeTab.id, { messages: [...messageHistory, errorMessage] });
        } finally { setIsLoading(false); }
    };
    const handleSend = () => {
        const canSend = (input.trim().length > 0 || images.length > 0) && !isLoading;
        if (!canSend || !activeTab) return;
        const userMessage = { id: Date.now().toString(), role: 'user', text: input, images: images };
        const updatedMessages = [...messages, userMessage];
        const newTabName = messages.length === 0 ? input.substring(0, 20) : activeTab.name;
        setInput('');
        setImages([]);
        performSend(updatedMessages, newTabName);
    };
    const handleEditSave = () => {
        if (!editingMessage || !activeTab) return;
        const messageIndex = messages.findIndex(m => m.id === editingMessage.id);
        if (messageIndex === -1) return;
        const updatedMessages = messages.slice(0, messageIndex);
        updatedMessages.push({ ...messages[messageIndex], text: editingMessage.text, images: messages[messageIndex].images });
        setEditingMessage(null);
        performSend(updatedMessages);
    };
    const handleCopy = (text) => navigator.clipboard.writeText(text);
    if (!activeTab) return <div className="p-4">Loading chat...</div>;
    return (
        <div className="h-full flex flex-col">
            {isCameraOpen && <CameraView onCapture={handlePhotoCapture} onClose={() => setIsCameraOpen(false)} />}
            <TabView tabs={tabs} activeTabId={activeTabId} onTabClick={setActiveTabId} onAddTab={addTab} onCloseTab={closeTab} featureName="Chat" />
            <div className="flex-grow overflow-y-auto mb-40 space-y-4 px-4">
                {messages.map((msg) => <MessageBubble key={msg.id} msg={msg} editingMessage={editingMessage} playingMessageId={playingMessageId} setEditingMessage={setEditingMessage} handleEditSave={handleEditSave} handleCopy={handleCopy} handlePlaybackToggle={handlePlaybackToggle}/>)}
                {isLoading && (<div className="flex items-end gap-2 justify-start"><div className="max-w-xs p-3 rounded-2xl bg-mirova-card-light dark:bg-mirova-card-dark text-gray-800 dark:text-gray-200 rounded-bl-none"><div className="flex items-center space-x-2"><div className="w-2 h-2 bg-purple-400 rounded-full animate-pulse"></div><div className="w-2 h-2 bg-purple-400 rounded-full animate-pulse [animation-delay:0.2s]"></div><div className="w-2 h-2 bg-purple-400 rounded-full animate-pulse [animation-delay:0.4s]"></div></div></div></div>)}
                <div ref={messagesEndRef} />
            </div>
            <ChatInputBar input={input} setInput={setInput} images={images} setImages={setImages} isLoading={isLoading} handleSend={handleSend} sttStatus={sttStatus} toggleRecording={toggleRecording} handleFileUpload={handleFileUpload} setIsCameraOpen={setIsCameraOpen}/>
        </div>
    );
};
const ImageView = () => {
    const { addHistoryItem } = useContext(HistoryContext);
    const { tabs, activeTabId, setActiveTabId, addTab, closeTab, updateTab } = useContext(ImageContext);
    const { language } = useContext(SttContext);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const fileInputRef = useRef(null);
    const activeTab = tabs.find(t => t.id === activeTabId);
    const handleTranscription = (text) => {
        if (activeTab) updateTab(activeTabId, { prompt: activeTab.prompt ? `${activeTab.prompt} ${text}` : text });
    };
    const { status: sttStatus, toggleRecording } = useSpeechToText(handleTranscription, language);
    const handleFileChange = async (event) => {
        if (!activeTab) return;
        const files = event.target.files;
        if (files) {
            if (activeTab.sourceImages.length + files.length > 50) { alert('You can upload a maximum of 50 images.'); return; }
            const filePromises = [...files].map(fileToBase64);
            const results = await Promise.all(filePromises);
            updateTab(activeTabId, { sourceImages: [...activeTab.sourceImages, ...results] });
        }
    };
    const canGenerate = activeTab && activeTab.prompt.trim().length > 0 && !isLoading;
    const handleGenerate = async () => {
        if (!canGenerate) return;
        setIsLoading(true);
        updateTab(activeTabId, { generatedImage: null });
        setError('');
        try {
            let base64Image;
            if (activeTab.sourceImages.length > 0) base64Image = await API.editImage(activeTab.prompt, activeTab.sourceImages, activeTab.resolution);
            else base64Image = await API.getImage(activeTab.prompt, activeTab.style, activeTab.resolution);
            const newTabState = { ...activeTab, generatedImage: base64Image, name: activeTab.name || activeTab.prompt.substring(0,20) };
            updateTab(activeTabId, newTabState);
            addHistoryItem({ feature: Feature.Image, payload: newTabState });
        } catch (err) {
            console.error(err);
            setError('Failed to generate image. Please try again.');
        } finally { setIsLoading(false); }
    };
    const styles = ['Realistic', '3D', 'Anime', 'Digital Art', 'Cartoon'];
    const aspectRatios = [
        { value: '1:1', label: 'Square (1:1) - Profile Pictures, Instagram' },
        { value: '16:9', label: 'Widescreen (16:9) - YouTube Thumbnail & Banner' },
        { value: '9:16', label: 'Portrait (9:16) - YouTube Shorts, Stories, TikTok' },
        { value: '4:3', label: 'Standard (4:3) - Classic Displays, Photography' },
        { value: '3:4', label: 'Tall (3:4) - Print, Posters' },
    ];
    if (!activeTab) return null;
    return (
        <div className="p-4 space-y-6">
            <TabView tabs={tabs} activeTabId={activeTabId} onTabClick={setActiveTabId} onAddTab={addTab} onCloseTab={closeTab} featureName="Image" />
            <GlassCard>
                <h2 className="text-xl font-bold mb-4 text-gray-800 dark:text-gray-200">Image Generation</h2>
                <div className="space-y-4">
                    <div className="relative">
                        <textarea value={activeTab.prompt} onChange={e => updateTab(activeTabId, { prompt: e.target.value })} placeholder={activeTab.sourceImages.length > 0 ? "Combine images into a YouTube thumbnail..." : "A robot holding a red skateboard..."} className="w-full p-2 pr-12 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all" rows={3}></textarea>
                        <button onClick={toggleRecording} className="absolute top-1/2 right-2 -translate-y-1/2 p-1 text-gray-600 dark:text-gray-400 hover:text-purple-500" aria-label="Use microphone">{sttStatus === 'transcribing' ? <LoadingSpinner size="sm" /> : sttStatus === 'recording' ? <div className="w-6 h-6 flex items-center justify-center text-red-500"><SttIcon className="w-6 h-6 animate-pulse" /></div> : <SttIcon className="w-6 h-6" />}</button>
                    </div>
                    {activeTab.sourceImages.length > 0 && (<div className="p-2 bg-black/10 dark:bg-white/5 rounded-lg"><div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2 max-h-48 overflow-y-auto">{activeTab.sourceImages.map((img, index) => (<div key={index} className="relative"><img src={`data:${img.mimeType};base64,${img.data}`} className="w-full h-auto object-cover rounded-md aspect-square"/><button onClick={() => updateTab(activeTabId, { sourceImages: activeTab.sourceImages.filter((_, i) => i !== index) })} className="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold">X</button></div>))}</div></div>)}
                    <button onClick={() => fileInputRef.current?.click()} className="w-full py-2 border-2 border-dashed border-purple-400/50 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-purple-400/10 transition-colors">Upload Image(s) to Edit (Optional)</button>
                     <input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" className="hidden" multiple />
                    {activeTab.sourceImages.length === 0 && (<div><label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Style</label><select value={activeTab.style} onChange={e => updateTab(activeTabId, { style: e.target.value })} className="w-full p-2 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">{styles.map(s => <option key={s} value={s}>{s}</option>)}</select></div>)}
                    <div><label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Aspect Ratio</label><select value={activeTab.resolution} onChange={e => updateTab(activeTabId, { resolution: e.target.value })} className="w-full p-2 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">{aspectRatios.map(({ value, label }) => <option key={value} value={value}>{label}</option>)}</select></div>
                    <button onClick={handleGenerate} disabled={!canGenerate} className="w-full py-3 bg-gradient-to-r from-purple-600 to-blue-500 text-white font-bold rounded-lg shadow-lg hover:scale-105 transition-transform disabled:opacity-50 disabled:cursor-not-allowed">{isLoading ? 'Generating...' : (activeTab.sourceImages.length > 0 ? 'Edit Image(s)' : 'Generate Image')}</button>
                </div>
            </GlassCard>
            {isLoading && <div className="flex justify-center items-center my-8"><LoadingSpinner /></div>}
            {error && <p className="text-red-500 text-center">{error}</p>}
            {activeTab.generatedImage && (<GlassCard><img src={`data:image/jpeg;base64,${activeTab.generatedImage}`} alt={activeTab.prompt} className="rounded-lg w-full" /><a href={`data:image/jpeg;base64,${activeTab.generatedImage}`} download="mirova-image.jpg" className="mt-4 w-full block text-center py-2 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition-colors">Download Image</a></GlassCard>)}
        </div>
    );
};
const languages = { 'JavaScript': 'js', 'Python': 'py', 'Dart': 'dart', 'Java': 'java', 'C++': 'cpp', 'C#': 'cs', 'Go': 'go', 'Rust': 'rs', 'TypeScript': 'ts', 'HTML': 'html', 'CSS': 'css', 'SQL': 'sql', 'Swift': 'swift', 'Kotlin': 'kt', 'Ruby': 'rb', 'PHP': 'php' };
const MirovaCoderView = () => {
    const { addHistoryItem } = useContext(HistoryContext);
    const { tabs, activeTabId, setActiveTabId, addTab, closeTab, updateTab } = useContext(CoderContext);
    const [isLoading, setIsLoading] = useState(false);
    const [copied, setCopied] = useState(false);
    const activeTab = tabs.find(t => t.id === activeTabId);
    const handleGenerate = async () => {
        if (!activeTab || !activeTab.prompt.trim()) return;
        setIsLoading(true);
        updateTab(activeTabId, { result: '' });
        try {
            const code = await API.generateCode(activeTab.prompt, activeTab.language);
            const newTabState = { ...activeTab, result: code, name: activeTab.name || activeTab.prompt.substring(0, 20) };
            updateTab(activeTabId, newTabState);
            addHistoryItem({ feature: Feature.MirovaCoder, payload: newTabState });
        } catch(e) {
            console.error(e);
            updateTab(activeTabId, { result: "An error occurred while generating the code." });
        } finally { setIsLoading(false); }
    };
    const handleCopy = () => {
        if (!activeTab?.result) return;
        const codeMatch = activeTab.result.match(/```(?:\w*\n)?([\s\S]*?)```/);
        const textToCopy = codeMatch ? codeMatch[1] : activeTab.result;
        navigator.clipboard.writeText(textToCopy).then(() => {
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        });
    };
    const handleDownload = () => {
        if (!activeTab?.result) return;
        const codeMatch = activeTab.result.match(/```(?:\w*\n)?([\s\S]*?)```/);
        const textToDownload = codeMatch ? codeMatch[1] : activeTab.result;
        const fileExtension = languages[activeTab.language] || 'txt';
        const blob = new Blob([textToDownload], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `mirova-code.${fileExtension}`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };
    if (!activeTab) return null;
    return (
        <div className="p-4 space-y-6">
            <TabView tabs={tabs} activeTabId={activeTabId} onTabClick={setActiveTabId} onAddTab={addTab} onCloseTab={closeTab} featureName="Coder" />
            <GlassCard>
                <h2 className="text-xl font-bold mb-4 text-gray-800 dark:text-gray-200">Mirova Coder</h2>
                <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">Describe the app or code you want to build, select a language, and let MIROVA write the code for you.</p>
                <div className="space-y-4">
                    <textarea value={activeTab.prompt} onChange={e => updateTab(activeTabId, { prompt: e.target.value })} placeholder="A Python script that organizes files in a directory by their extension..." className="w-full p-2 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500" rows={4}></textarea>
                    <div><label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Programming Language</label><select value={activeTab.language} onChange={e => updateTab(activeTabId, { language: e.target.value })} className="w-full p-2 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">{Object.keys(languages).map(lang => <option key={lang} value={lang}>{lang}</option>)}</select></div>
                    <button onClick={handleGenerate} disabled={isLoading} className="w-full py-3 bg-gradient-to-r from-purple-600 to-blue-500 text-white font-bold rounded-lg shadow-lg hover:scale-105 transition-transform disabled:opacity-50">{isLoading ? 'Generating Code...' : 'Generate Code'}</button>
                </div>
            </GlassCard>
            {isLoading && <div className="flex justify-center items-center my-8"><LoadingSpinner /></div>}
            {activeTab.result && (<GlassCard><div className="flex justify-between items-center mb-2 bg-gray-900/50 p-2 rounded-t-lg"><span className="font-mono text-sm text-cyan-300">{activeTab.language}</span><div className="flex items-center gap-2"><button onClick={handleCopy} className="flex items-center gap-1.5 px-2 py-1 text-xs font-semibold rounded-md transition-colors bg-gray-600 text-white hover:bg-gray-500"><CopyIcon className="w-3.5 h-3.5" />{copied ? 'Copied!' : 'Copy'}</button><button onClick={handleDownload} className="flex items-center gap-1.5 px-2 py-1 text-xs font-semibold rounded-md transition-colors bg-gray-600 text-white hover:bg-gray-500"><DownloadIcon className="w-3.5 h-3.5" />Download</button></div></div><div className="bg-gray-800/80 p-4 rounded-b-lg overflow-x-auto max-h-96"><div className="prose prose-sm dark:prose-invert max-w-none prose-pre:bg-transparent prose-pre:p-0" dangerouslySetInnerHTML={{ __html: window.marked.parse(activeTab.result || '') }}></div></div></GlassCard>)}
        </div>
    );
};
const SttView = () => {
    const { addHistoryItem } = useContext(HistoryContext);
    const { transcription, setTranscription, language, setLanguage } = useContext(SttContext);
    const [status, setStatus] = useState('idle');
    const [error, setError] = useState('');
    const [selectedFile, setSelectedFile] = useState(null);
    const [copied, setCopied] = useState(false);
    const fileInputRef = useRef(null), mediaRecorderRef = useRef(null), audioChunksRef = useRef([]);
    const languages = ['Telugu', 'English', 'Hindi', 'Bengali', 'Marathi', 'Tamil', 'Urdu', 'Gujarati', 'Kannada', 'Malayalam', 'Punjabi'];
    const cleanup = () => { mediaRecorderRef.current = null; audioChunksRef.current = []; setSelectedFile(null); setStatus('idle'); };
    const handleCopy = () => { if (!transcription) return; navigator.clipboard.writeText(transcription).then(() => { setCopied(true); setTimeout(() => setCopied(false), 2000); }); };
    const handleTranscriptionStream = async (audioChunks, prompt) => {
        setStatus('transcribing'); setTranscription('');
        try {
            const stream = await API.transcribeAudioStream(audioChunks, language);
            let fullText = '';
            for await (const chunk of stream) { fullText += chunk.text; setTranscription(fullText); }
            if (fullText) addHistoryItem({ feature: Feature.STT, payload: { language, prompt, result: { text: fullText } } });
        } catch (err) { console.error("Transcription error:", err); setError("Failed to transcribe the audio. Please try again.");
        } finally { cleanup(); }
    };
    const startRecording = async () => {
        if (status !== 'idle') return;
        setStatus('recording'); setError(''); setTranscription(''); audioChunksRef.current = [];
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorderRef.current = new MediaRecorder(stream);
            mediaRecorderRef.current.ondataavailable = (event) => audioChunksRef.current.push(event.data);
            mediaRecorderRef.current.start();
        } catch (err) { console.error("Microphone access error:", err); setError("Could not access microphone. Please grant permission."); setStatus('idle'); }
    };
    const stopRecording = () => {
        if (status !== 'recording' || !mediaRecorderRef.current) return;
        mediaRecorderRef.current.onstop = async () => {
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            const reader = new FileReader(); reader.readAsDataURL(audioBlob);
            reader.onloadend = () => {
                const base64data = reader.result;
                const audio = { data: base64data.split(',')[1], mimeType: 'audio/webm' };
                handleTranscriptionStream([audio], 'Live Recording');
            };
            mediaRecorderRef.current?.stream.getTracks().forEach(track => track.stop());
        };
        mediaRecorderRef.current.stop(); setStatus('processing');
    };
    const handleFileSelect = (event) => {
        const file = event.target.files?.[0];
        if (file && status === 'idle') { setSelectedFile(file); setError(''); setTranscription(''); handleTranscribeFile(file); }
    };
    const handleTranscribeFile = async (file) => {
        setStatus('processing');
        try {
            const audioCtx = new AudioContext();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = audioBuffer; source.connect(offlineCtx.destination); source.start();
            const renderedBuffer = await offlineCtx.startRendering();
            const wavBlob = bufferToWave(renderedBuffer);
            const reader = new FileReader(); reader.readAsDataURL(wavBlob);
            reader.onloadend = () => {
                const base64data = reader.result;
                const audio = { data: base64data.split(',')[1], mimeType: 'audio/wav' };
                handleTranscriptionStream([audio], `File: ${file.name}`);
            };
        } catch (err) { console.error("File processing error:", err); setError("Failed to process the audio file. It may be corrupted or in an unsupported format."); cleanup(); }
    };
    const bufferToWave = (abuffer) => {
        const numOfChan = abuffer.numberOfChannels, length = abuffer.length * numOfChan * 2 + 44;
        const buffer = new ArrayBuffer(length), view = new DataView(buffer), channels = [];
        let i, sample, offset = 0, pos = 0;
        for(i = 0; i < numOfChan; i++) channels.push(abuffer.getChannelData(i));
        setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
        setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
        setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
        setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4);
        for(i = 0; i < abuffer.length; i++) {
            for(let ch = 0; ch < numOfChan; ch++) {
                sample = Math.max(-1, Math.min(1, channels[ch][i]));
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                view.setInt16(pos, sample, true); pos += 2;
            }
        }
        return new Blob([view], { type: 'audio/wav' });
        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
    }
    const getStatusText = () => {
        switch (status) {
            case 'recording': return 'Listening...';
            case 'processing': return `Processing: ${selectedFile?.name || 'Live Audio'}`;
            case 'transcribing': return 'Transcribing...';
            default: return 'Select a language, then record or upload';
        }
    }
    return (
        <div className="p-4 space-y-6">
            <GlassCard className="text-center">
                <h2 className="text-xl font-bold mb-4 text-gray-800 dark:text-gray-200">Speech to Text</h2>
                <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">Select the language, then record your voice or upload an audio file for a complete transcription.</p>
                <div className="mb-6">
                    <label htmlFor="language-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Audio Language</label>
                    <select id="language-select" value={language} onChange={e => setLanguage(e.target.value)} disabled={status !== 'idle'} className="w-full max-w-xs mx-auto p-2 bg-white/50 dark:bg-black/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 disabled:opacity-50">{languages.map(lang => <option key={lang} value={lang}>{lang}</option>)}</select>
                </div>
                <div className="flex justify-center items-center gap-4">
                    <button onClick={status === 'recording' ? stopRecording : startRecording} disabled={(status !== 'idle' && status !== 'recording') || !!selectedFile} className={`relative w-24 h-24 rounded-full transition-all duration-300 flex items-center justify-center mx-auto disabled:opacity-50 disabled:cursor-not-allowed ${status === 'recording' ? 'bg-red-500 shadow-neon-purple' : 'bg-purple-600 shadow-lg'}`}>{status === 'recording' ? <div className="w-8 h-8 bg-white rounded-md"></div> : <SttIcon className="w-10 h-10 text-white" />}{status === 'recording' && <div className="absolute inset-0 rounded-full border-2 border-white animate-ping"></div>}</button>
                    <div className="text-2xl text-gray-400 dark:text-gray-600">OR</div>
                     <input type="file" ref={fileInputRef} onChange={handleFileSelect} accept="audio/*,video/*" className="hidden" />
                     <button onClick={() => fileInputRef.current?.click()} disabled={status !== 'idle'} className="w-24 h-24 border-2 border-dashed border-purple-400/50 rounded-full flex flex-col items-center justify-center text-gray-600 dark:text-gray-300 hover:bg-purple-400/10 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><UploadIcon className="w-8 h-8 mb-1"/><span className="text-xs">Upload File</span></button>
                </div>
                 <p className="mt-4 text-sm font-semibold h-5">{getStatusText()}</p>
            </GlassCard>
            {(status === 'processing' || status === 'transcribing') && (<GlassCard><div className="flex flex-col items-center justify-center"><div className="flex justify-center items-center my-8"><LoadingSpinner /></div><p className="mt-2 text-gray-600 dark:text-gray-300">{status === 'processing' ? 'Preparing audio for transcription...' : 'Transcribing...'}</p></div></GlassCard>)}
            {error && <p className="text-red-500 text-center bg-red-500/10 p-2 rounded-lg">{error}</p>}
            {transcription && (<GlassCard><div className="flex justify-between items-center mb-2"><h3 className="font-bold text-gray-800 dark:text-gray-200">Transcription:</h3><button onClick={handleCopy} className={`px-3 py-1 text-sm font-semibold rounded-md transition-colors ${copied ? 'bg-green-500 text-white' : 'bg-purple-500 text-white hover:bg-purple-600'}`}>{copied ? 'Copied!' : 'Copy'}</button></div><div className="bg-black/5 dark:bg-white/5 p-3 rounded-lg"><p className="text-gray-700 dark:text-gray-300 whitespace-pre-wrap max-h-60 overflow-y-auto">{transcription}</p></div></GlassCard>)}
        </div>
    );
};
const HistoryView = ({ loadItemFromHistory }) => {
    const { history, clearHistory } = useContext(HistoryContext);
    const getPrompt = (item) => {
        if (item.feature === Feature.STT) return item.payload.prompt;
        return item.payload.prompt || item.payload.name || 'Chat Session';
    }
    const getResult = (item) => {
        if(item.feature === Feature.Chat) {
            const lastModelMessage = item.payload.messages.filter(m => m.role === 'model').pop();
            return lastModelMessage?.text;
        }
        if(item.feature === Feature.Image) return item.payload.generatedImage;
        return item.payload.result?.text || item.payload.result;
    }
    return (
        <div className="p-4 space-y-6">
            <GlassCard>
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200">History</h2>
                    {history.length > 0 && <button onClick={clearHistory} className="px-3 py-1 bg-red-500 text-white text-sm font-semibold rounded-md hover:bg-red-600 transition-colors">Clear All</button>}
                </div>
                {history.length === 0 ? <p className="text-center text-gray-600 dark:text-gray-400">Your history is empty. Start creating!</p> : (
                    <div className="space-y-4 max-h-[65vh] overflow-y-auto pr-2">
                        {history.map(item => (
                            <div key={item.id} className="p-4 bg-white/50 dark:bg-black/20 rounded-lg transition-all cursor-pointer hover:ring-2 hover:ring-purple-500" onClick={() => loadItemFromHistory(item)}>
                                <div className="flex justify-between items-center mb-2"><span className="font-bold text-purple-600 dark:text-purple-400">{item.feature}</span><span className="text-xs text-gray-500 dark:text-gray-400">{new Date(item.timestamp).toLocaleString()}</span></div>
                                <p className="text-sm text-gray-600 dark:text-gray-300 mb-2 truncate"><strong>Prompt:</strong> {getPrompt(item)}</p>
                                {getResult(item) && item.feature !== Feature.Image && <p className="text-sm text-gray-800 dark:text-gray-200 bg-black/5 dark:bg-white/5 p-2 rounded-md max-h-24 overflow-y-auto">{getResult(item)}</p>}
                                {getResult(item) && item.feature === Feature.Image && <img src={`data:image/jpeg;base64,${getResult(item)}`} alt={getPrompt(item)} className="rounded-lg mt-2 max-h-48" />}
                            </div>
                        ))}
                    </div>
                )}
            </GlassCard>
        </div>
    );
};
const AboutView = () => {
    const age = API.getVikasAge();
    return (
        <div className="p-4 space-y-6">
            <GlassCard>
                <div className="flex justify-between items-center mb-4"><h2 className="text-xl font-bold text-gray-800 dark:text-gray-200">About MIROVA</h2></div>
                <div className="space-y-4 text-gray-700 dark:text-gray-300">
                    <p className="font-semibold text-lg">MIROVA is a 100% Free and Unlimited AI Assistant App.</p>
                    <p>You can use all its features — Chat, Image, Voice, and App Builder — without any API keys or limits.</p>
                    <p>Developed by G. Vikas, age {age}.</p>
                    <p className="font-bold">MIROVA is for everyone, everywhere — totally free forever.</p>
                </div>
            </GlassCard>
        </div>
    );
};


// ====== FROM App.tsx ======
const App = () => (
    <AuthProvider>
      <HistoryProvider>
        <ChatProvider><ImageProvider><CoderProvider><SttProvider>
            <MirovaApp />
        </SttProvider></CoderProvider></ImageProvider></ChatProvider>
      </HistoryProvider>
    </AuthProvider>
);
const MirovaApp = () => {
    const { user } = useContext(AuthContext);
    const [isSplashing, setIsSplashing] = useState(true);
    useEffect(() => {
        const timer = setTimeout(() => setIsSplashing(false), 3500);
        return () => clearTimeout(timer);
    }, []);
    const [theme, setTheme] = useState(() => {
        if (typeof window !== 'undefined' && window.localStorage) {
          const storedTheme = window.localStorage.getItem('mirova-theme');
          return storedTheme || Theme.Dark;
        }
        return Theme.Dark;
    });
    useEffect(() => {
        const root = window.document.documentElement;
        root.classList.remove(theme === Theme.Dark ? Theme.Light : Theme.Dark);
        root.classList.add(theme);
        localStorage.setItem('mirova-theme', theme);
    }, [theme]);
    return (
        <div className={`min-h-screen font-sans ${theme === Theme.Light ? 'bg-mirova-bg-light text-gray-900' : 'bg-mirova-bg-dark text-gray-100 dark'} transition-colors duration-300`}>
            {isSplashing ? <SplashScreen /> : !user ? <AuthScreens /> : <MainApp theme={theme} setTheme={setTheme} />}
        </div>
    );
};
const MainApp = ({ theme, setTheme }) => {
    const [activeFeature, setActiveFeature] = useState(Feature.Chat);
    const chatContext = useContext(ChatContext);
    const imageContext = useContext(ImageContext);
    const coderContext = useContext(CoderContext);
    const sttContext = useContext(SttContext);
    const loadItemFromHistory = (item) => {
        if (!item) return;
        switch (item.feature) {
            case Feature.Chat: chatContext.addTab(item.payload); break;
            case Feature.Image: imageContext.addTab(item.payload); break;
            case Feature.MirovaCoder: coderContext.addTab(item.payload); break;
            case Feature.STT:
                const sttPayload = item.payload;
                sttContext.setLanguage(sttPayload.language);
                sttContext.setTranscription(sttPayload.result.text || '');
                break;
        }
        setActiveFeature(item.feature);
    };
    const renderFeature = () => {
        switch (activeFeature) {
          case Feature.Chat: return <ChatView />;
          case Feature.Image: return <ImageView />;
          case Feature.MirovaCoder: return <MirovaCoderView />;
          case Feature.STT: return <SttView />;
          case Feature.History: return <HistoryView loadItemFromHistory={loadItemFromHistory} />;
          case Feature.About: return <AboutView />;
          default: return <ChatView />;
        }
    };
    return (
        <>
           <div className="absolute inset-0 z-0 overflow-hidden">
                <div className="absolute top-0 -left-1/4 w-full h-full bg-gradient-to-br from-purple-900/50 via-blue-900/30 to-transparent rounded-full filter blur-3xl animate-pulse opacity-30 dark:opacity-50"></div>
                <div className="absolute bottom-0 -right-1/4 w-full h-full bg-gradient-to-tl from-indigo-900/50 via-pink-900/30 to-transparent rounded-full filter blur-3xl animate-pulse animation-delay-4000 opacity-30 dark:opacity-50"></div>
            </div>
            <div className="relative z-10 min-h-screen flex flex-col">
                <Header theme={theme} setTheme={setTheme} />
                <main className="flex-grow pt-16 pb-28"><div className="container mx-auto px-4 sm:px-6 lg:px-8 h-full">{renderFeature()}</div></main>
                <FloatingMenu activeFeature={activeFeature} setActiveFeature={setActiveFeature} />
            </div>
        </>
    );
};


// ====== FROM index.tsx ======
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>